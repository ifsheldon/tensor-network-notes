# AUTOGENERATED! DO NOT EDIT! File to edit: ../1-8.ipynb.

# %% auto 0
__all__ = ['outer_product', 'rank1_decomposition']

# %% ../1-8.ipynb 0
import torch
from tqdm.auto import tqdm
from typing import List

# %% ../1-8.ipynb 3
def outer_product(vectors: List[torch.Tensor]) -> torch.Tensor:
    for v in vectors:
        assert v.dim() == 1
    num_vectors = len(vectors)
    assert num_vectors >= 2
    # if num_vectors <= 26, we can just use einsum
    if num_vectors <= 26:
        alphabet = "abcdefghijklmnopqrstuvwxyz"
        input_string = ",".join(c for c in alphabet[:num_vectors])
        output_string = alphabet[:num_vectors]
        einsum_exp = f"{input_string} -> {output_string}"
        return torch.einsum(einsum_exp, *vectors)
    else:
        reshaped_vectors = []
        for (i, v) in enumerate(vectors):
            # calculate shapes
            s = torch.ones(num_vectors, dtype=torch.int)
            s[i] = v.shape[0]
            s = s.tolist()
            reshaped_vectors.append(v.reshape(s))

        # broadcast multiplication
        v = reshaped_vectors[0]
        for i in range(1, num_vectors):
            v = v * reshaped_vectors[i]
        return v


# %% ../1-8.ipynb 5
def rank1_decomposition(tensor: torch.Tensor, num_iter: int = 1000, eps: float = 1e-10) -> List[torch.Tensor]:
    t_shape = tensor.shape
    k = len(t_shape)
    decomposed_vecs = [torch.randn(d, dtype=tensor.dtype) for d in t_shape]
    decomposed_vecs = [v / v.norm() for v in decomposed_vecs]
    zeta = 1.
    for _ in tqdm(range(num_iter)):
        for idx in range(k):
            vs = decomposed_vecs[:idx] + decomposed_vecs[idx + 1:]
            outer = outer_product(vs).unsqueeze(idx)
            sum_indices = list(range(k))
            sum_indices.pop(idx)
            vi = (tensor * outer).sum(tuple(sum_indices))
            vi /= vi.norm()
            decomposed_vecs[idx] = vi

        zeta_new = (tensor * outer_product(decomposed_vecs)).sum()
        if (zeta_new - zeta).norm() < eps:
            break
        zeta = zeta_new

    return decomposed_vecs
