# AUTOGENERATED! DO NOT EDIT! File to edit: ../../0-utils-data.ipynb.

# %% auto 0
__all__ = ['load_iris', 'split_classification_dataset']

# %% ../../0-utils-data.ipynb 0
from typing import Tuple
import torch
from torch.utils import data
from torchvision import datasets, transforms

# %% ../../0-utils-data.ipynb 2
def load_iris(*, force_single_precision=False) -> Tuple[torch.Tensor, torch.Tensor]:
    """
    Load the Iris dataset and return the data and targets.

    Args:
        force_single_precision: Whether to force the data to be single precision.
    Returns:
        Tuple[torch.Tensor, torch.Tensor]: The data and targets.
    """
    from sklearn import datasets

    iris = datasets.load_iris()
    data = torch.from_numpy(iris["data"])
    if force_single_precision:
        data = data.float()

    targets = torch.from_numpy(iris["target"]).to(torch.long)
    return data, targets

# %% ../../3-5.ipynb 20
def split_classification_dataset(
    data: torch.Tensor, targets: torch.Tensor, ratio: float, shuffle: bool = True
) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor, torch.Tensor]:
    """
    Split the dataset into training and testing sets.

    Args:
        data (torch.Tensor): The data tensor.
        target (torch.Tensor): The target tensor.
        ratio (float): The ratio of the training set.
        shuffle (bool): Whether to shuffle the data.

    Returns:
        Tuple[torch.Tensor, torch.Tensor, torch.Tensor, torch.Tensor]: The training samples, training labels, testing samples, testing labels.
    """
    assert targets.dtype in [torch.int, torch.long], "target must be an integer tensor"
    assert 1.0 > ratio > 0.0, "ratio must be between 0 and 1"
    num_classes = torch.max(targets) + 1
    num_samples = data.shape[0]
    assert num_samples == targets.shape[0], "data and target must have the same number of samples"
    train_samples = []
    train_labels = []
    test_samples = []
    test_labels = []
    for class_idx in range(num_classes):
        sample_class_i = data[targets == class_idx]
        num_samples_class_i = sample_class_i.shape[0]
        num_train = int(num_samples_class_i * (1 - ratio))
        if shuffle:
            shuffle_idx = torch.randperm(num_samples_class_i)
            shuffled_sample_class_i = sample_class_i[shuffle_idx]
            train_sample = shuffled_sample_class_i[:num_train]
            train_samples.append(train_sample)
            test_sample = shuffled_sample_class_i[num_train:]
            test_samples.append(test_sample)

            train_labels.append(
                torch.full((train_sample.shape[0],), class_idx, dtype=targets.dtype)
            )
            test_labels.append(torch.full((test_sample.shape[0],), class_idx, dtype=targets.dtype))
        else:
            train_sample = sample_class_i[:num_train]
            train_samples.append(train_sample)
            test_sample = sample_class_i[num_train:]
            test_samples.append(test_sample)
            train_labels.append(
                torch.full((train_sample.shape[0],), class_idx, dtype=targets.dtype)
            )
            test_labels.append(torch.full((test_sample.shape[0],), class_idx, dtype=targets.dtype))

    train_samples = torch.cat(train_samples, dim=0)
    train_labels = torch.cat(train_labels, dim=0)
    test_samples = torch.cat(test_samples, dim=0)
    test_labels = torch.cat(test_labels, dim=0)
    return train_samples, train_labels, test_samples, test_labels