# AUTOGENERATED! DO NOT EDIT! File to edit: ../1-4.ipynb.

# %% auto 0
__all__ = ['identity_tensor', 'zeros_state', 'normalize_tensor', 'rescale_tensor']

# %% ../1-4.ipynb 0
import torch

# %% ../1-4.ipynb 5
def identity_tensor(order: int, dim: int, dtype: torch.dtype = torch.float32) -> torch.Tensor:
    """
    Create an identity tensor of given order and dimension.
    Args:
        order (int): The order of the tensor.
        dim (int): The dimension of the tensor.
        dtype (torch.dtype): The data type of the tensor. Default is torch.float32.
    Returns:
        torch.Tensor: The identity tensor of shape (dim, dim, ..., dim) with the specified order.
    """
    dims = [dim] * order
    I = torch.zeros(*dims, dtype=dtype)
    for i in range(dim):
        indices = [i] * order
        I[tuple(indices)] = 1.0

    return I

# %% ../3-1.ipynb 7
def zeros_state(*, num_qubits: int, dtype: torch.dtype) -> torch.Tensor:
    """
    Returns the zero state as a tensor.
    Args:
        num_qubits (int): The number of qubits.
        dtype (torch.dtype): The data type of the tensor.
    Returns:
        torch.Tensor: The zero state as a tensor.
    """
    assert num_qubits > 0, "num_qubits must be positive"
    assert dtype in [torch.complex64, torch.complex128], "dtype must be complex64 or complex128"
    state = torch.zeros((2**num_qubits,), dtype=dtype)
    state[0] = 1.0
    shape = [2] * num_qubits
    state = state.reshape(shape)
    return state

# %% ../3-5.ipynb 19
from typing import Tuple


def normalize_tensor(tensor: torch.Tensor, dim: int | None = None) -> torch.Tensor:
    """
    Normalize a tensor to the range [0, 1].

    Args:
        tensor (torch.Tensor): The tensor to normalize.
        dim (int | None, optional): The dimension along which to normalize.
            If None, normalizes across the entire tensor. Defaults to None.

    Returns:
        torch.Tensor: The normalized tensor with values in the range [0, 1].
    """
    if dim is None:
        min_val = torch.min(tensor)
        max_val = torch.max(tensor)
    else:
        min_val = torch.min(tensor, dim, keepdim=True).values
        max_val = torch.max(tensor, dim, keepdim=True).values
    return (tensor - min_val) / (max_val - min_val)


def rescale_tensor(
    tensor: torch.Tensor, min_val: float, max_val: float, dim: None | int | Tuple[int, ...] = None
) -> torch.Tensor:
    """
    Rescale a tensor to a specified range.

    Args:
        tensor (torch.Tensor): The tensor to rescale.
        min_val (float): The minimum value of the target range.
        max_val (float): The maximum value of the target range.
        dim (None | int | Tuple[int, ...], optional): The dimension(s) along which to rescale.
            If None, rescales across the entire tensor. Defaults to None.

    Returns:
        torch.Tensor: The rescaled tensor with values in the range [min_val, max_val].
    """

    normalized_tensor = normalize_tensor(tensor, dim)
    return normalized_tensor * (max_val - min_val) + min_val