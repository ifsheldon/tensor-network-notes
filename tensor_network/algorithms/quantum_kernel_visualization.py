"""References:"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../4-8.ipynb.

# %% auto 0
__all__ = ['metric_matrix_neg_log_cos_sin', 'visualize_tsne']

# %% ../../4-8.ipynb 2
import torch
from sklearn.manifold import TSNE
import matplotlib.pyplot as plt
from ..utils.data import load_mnist_images
from typing import Literal

# %% ../../4-8.ipynb 6
def metric_matrix_neg_log_cos_sin(
    samples: torch.Tensor,
    theta: float = torch.pi / 2 - 1e-7,
    calculation_method: Literal["deduplicate", "no_deduplicate"] = "deduplicate",
) -> torch.Tensor:
    """
    Calculate the distance matrix between samples.

    Args:
        samples: samples of shape (N samples, feature num)
        theta: cossin mapping theta
        calculation_method: "deduplicate" or "no_deduplicate", "deduplicate" use symmetry to avoid duplicate calculation

    Returns:
        distance matrix of shape (N samples, N samples)
    """
    assert samples.ndim == 2  # (N samples, feature num)
    assert samples.min() >= 0.0, f"samples.min(): {samples.min()}"
    assert samples.max() <= 1.0, f"samples.max(): {samples.max()}"
    assert torch.pi / 2 >= theta >= 0.0
    assert calculation_method in ["deduplicate", "no_deduplicate"]
    sample_num = samples.shape[0]
    if calculation_method == "deduplicate":
        metric = torch.zeros(sample_num, sample_num, device=samples.device, dtype=samples.dtype)
        for n in range(sample_num - 1):
            sample_n = samples[n].reshape(1, -1)  # (1, feature num)
            others = samples[n + 1 :]  # (sample_num - n - 1, feature num)
            diff = sample_n - others  # (sample_num - n - 1, feature num)
            distances = -torch.log(torch.cos(diff * theta)).mean(dim=1)  # (sample_num - n - 1)
            assert not torch.isnan(distances).any(), "if there's nan, try to reduce theta"
            metric[n, n + 1 :] = distances
            metric[n + 1 :, n] = distances
    else:
        samples = samples.unsqueeze(0)  # (1, sample_num, feature num)
        others = samples.transpose(0, 1)  # (sample_num, 1, feature num)
        diff = samples - others  # (sample_num, sample_num, feature num)
        metric = -torch.log(torch.cos(diff * theta)).mean(dim=2)  # (sample_num, sample_num)

        for n in range(sample_num):
            metric[n, n] = 0.0

        assert not torch.isnan(metric).any(), "if there's nan, try to reduce theta"

    return metric

# %% ../../4-8.ipynb 10
def visualize_tsne(
    *,
    sample_distances: torch.Tensor,
    labels: torch.Tensor,
    perplexity: float,
    learning_rate: float | Literal["auto"] = "auto",
):
    """
    Create projection from data points to 2D space using t-SNE.

    Args:
        sample_distances: distance matrix of shape (N samples, N samples)
        labels: labels of shape (N samples,)
        perplexity: perplexity of t-SNE
        learning_rate: learning rate of t-SNE
    """
    assert sample_distances.ndim == 2
    sample_num = sample_distances.shape[0]
    assert sample_num == sample_distances.shape[1]
    assert labels.ndim == 1
    assert labels.shape[0] == sample_num
    assert sample_distances.min() >= 0.0, f"sample_distances.min(): {sample_distances.min()}"
    assert perplexity > 0.0
    assert learning_rate == "auto" or learning_rate > 0.0

    tsne = TSNE(
        perplexity=perplexity,
        init="random",
        n_components=2,
        learning_rate=learning_rate,
        metric="precomputed",
    )

    projected_samples = tsne.fit_transform(sample_distances)
    x = projected_samples[:, 0]
    x_min = x.min()
    x_max = x.max()
    x = (x - x_min) / (x_max - x_min)
    y = projected_samples[:, 1]
    y_min = y.min()
    y_max = y.max()
    y = (y - y_min) / (y_max - y_min)

    plt.figure(figsize=(4, 4))
    unique_labels = torch.unique(labels).tolist()
    colors = {l: plt.cm.tab10(l) for l in unique_labels}
    for i in range(sample_num):
        plt.text(
            x[i],
            y[i],
            str(labels[i].item()),
            color=colors[labels[i].item()],
            fontdict={"weight": "bold", "size": 9},
        )
    plt.xticks([])
    plt.yticks([])
    plt.show()
