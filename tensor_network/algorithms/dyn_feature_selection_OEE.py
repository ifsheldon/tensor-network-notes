"""例子：考虑在黑板上进行书写：如果要求仅在黑板的中间某个子区域进行书写，那么对于所有样本，该子区域之外的像素值不会发生变化（黑色），这个区间被称为背景。有用的信息（文字）出现在中间进行书写的子区域，我们将其称之为信息区。文字笔画对应的位置，则被称为关键性少数"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../4-10.ipynb.

# %% auto 0
__all__ = ['dyn_OEE_analyze']

# %% ../../4-10.ipynb 2
import torch
from ..feature_mapping import cossin_feature_map
from ..utils.tensors import outer_product
import numpy as np

# %% ../../4-10.ipynb 5
from ..quantum_state.functional import calc_onsite_entanglement_entropy, project_state


def dyn_OEE_analyze(samples: torch.Tensor, nth_img: int):
    """
    dynamic onsite entanglement entropy analysis
    """
    assert samples.ndim == 2, "samples must be a 2D tensor"  # (num_samples, num_features)
    assert samples.shape[1] >= 3
    num_samples, num_features = samples.shape
    features = cossin_feature_map(samples, theta=0.5)  # (num_samples, num_features, 2)
    tensor_states = torch.stack(
        [outer_product(features[i]) for i in range(num_samples)]
    )  # (num_samples, [2] * num_features)
    tensor_state = tensor_states.sum(dim=0) / np.sqrt(num_samples)

    oees = calc_onsite_entanglement_entropy(tensor_state)
    print(f"初始OEE = {oees}")
    total_oee = oees.sum()

    for feature_idx in range(num_features):
        print(
            f"根据第{feature_idx}个样本的特征取值 (x={samples[nth_img, feature_idx]})，投影测量第{feature_idx}个量子位"
        )
        projected_state = project_state(
            tensor_state, features[nth_img, feature_idx, :], feature_idx
        )
        new_oees = calc_onsite_entanglement_entropy(projected_state)
        oee_change = new_oees.sum() - total_oee
        print(f"\t 测量后，其余量子位OEE = {new_oees}")
        print(f"\t 测量前后OEE变化量 = {oee_change.item()}")
    print()
