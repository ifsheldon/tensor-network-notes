"""涉及到量子哈密顿量的概念，可以看 [2.8节的笔记](./2-8.ipynb)"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../3-8.ipynb.

# %% auto 0
__all__ = ['PolarizationGate', 'ADQCTimeEvolution']

# %% ../../3-8.ipynb 2
import torch
from einops import einsum
from torch import nn

# %% ../../3-8.ipynb 7
from torch import Tensor
from .adqc import ADQCNet
from ..tensor_gates.modules import QuantumGate
from typing import Set, Literal
from ..tensor_gates.functional import pauli_operator


class PolarizationGate(QuantumGate):
    def __init__(
        self,
        *,
        batched_input: bool,
        time_slice: float,
        target_qubit: int,
        h_directions: Set[Literal["x", "y", "z"]],
    ):
        assert isinstance(h_directions, set), "h_directions must be a list"
        assert 3 >= len(h_directions) > 0, "h_directions must be a non-empty set"
        assert all(direction in ["x", "y", "z"] for direction in h_directions), (
            "h_directions must contain only x, y, z"
        )
        assert time_slice > 0, "time_slice must be greater than 0"
        assert target_qubit >= 0, "target_qubit must be greater than or equal to 0"
        parameters = {}
        if "x" in h_directions:
            parameters["x"] = nn.Parameter(torch.randn(1), requires_grad=True)
        if "y" in h_directions:
            parameters["y"] = nn.Parameter(torch.randn(1), requires_grad=True)
        if "z" in h_directions:
            parameters["z"] = nn.Parameter(torch.randn(1), requires_grad=True)
        parameters = nn.ParameterDict(parameters)

        super().__init__(
            batched_input=batched_input,
            gate_params=parameters,
            requires_grad=True,
            target_qubit=target_qubit,
        )

        self.pauli_x = nn.Parameter(pauli_operator(pauli="X"), requires_grad=False)
        self.pauli_y = nn.Parameter(pauli_operator(pauli="Y"), requires_grad=False)
        self.pauli_z = nn.Parameter(pauli_operator(pauli="Z"), requires_grad=False)
        self.time_slice = time_slice

    def forward(self, tensor: Tensor) -> Tensor:
        pauli_matrix = 0
        if "x" in self.gate_params:
            pauli_matrix += self.gate_params["x"] * self.pauli_x
        if "y" in self.gate_params:
            pauli_matrix += self.gate_params["y"] * self.pauli_y
        if "z" in self.gate_params:
            pauli_matrix += self.gate_params["z"] * self.pauli_z

        gate = torch.matrix_exp(-0.5j * self.time_slice * pauli_matrix)
        return self.apply_gate(
            tensor=tensor,
            gate=gate,
            target_qubit=self.target_qubit,
        )


class ADQCTimeEvolution(nn.Module):
    def __init__(
        self,
        hamiltonian: torch.Tensor,
        num_qubits: int,
        time_steps: int,
        time_slice: float,
        h_directions: Set[Literal["x", "y", "z"]],
    ):
        super().__init__()
        assert hamiltonian.shape == (4, 4) or hamiltonian.shape == (2, 2, 2, 2), (
            "Hamiltonian must be a 4x4 matrix or 2x2x2x2 tensor"
        )
        assert num_qubits > 0, "Number of qubits must be greater than 0"
        assert time_steps > 0, "Time steps must be greater than 0"
        assert time_slice > 0, "Time slice must be greater than 0"
        U = torch.matrix_exp(-0.25j * time_slice * hamiltonian)
        per_layer_gate_pattern = ADQCNet.calc_gate_target_qubit_positions(
            gate_pattern="brick", num_qubits=num_qubits
        )
        gates = []
        for _ in range(time_steps):
            # gates for coupling
            for position in per_layer_gate_pattern:
                gates.append(
                    QuantumGate(
                        batched_input=False,
                        gate=U,
                        requires_grad=False,
                        target_qubit=list(position),
                    )
                )
            # gates for polarization
            for qubit_idx in range(num_qubits):
                gates.append(
                    PolarizationGate(
                        batched_input=False,
                        time_slice=time_slice,
                        target_qubit=qubit_idx,
                        h_directions=h_directions,
                    )
                )

        self.net = nn.Sequential(*gates)

    def forward(self, tensor: Tensor) -> Tensor:
        return self.net(tensor)
